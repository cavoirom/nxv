{"title":"OpenBSD's VPN","url":"/blog/entry/2021/01/14/openbsd-vpn","slug":"openbsd-vpn","author":"vinh","preview":"Setting up my home VPN with OpenBSD","created":"2021-01-14T00:48:59.379Z","updated":"2021-09-01T07:19:22.178Z","content":"<p><em>Note: I wrote the guideline based on OpenBSD 6.9.</em></p>\n<p>I'm going to set up VPN with <a href=\"https://man.openbsd.org/iked.8\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">iked</a>, a built-in\nVPN software from OpenBSD. The main focus of this setup is routing all outbound\ntraffic from clients to my <em><strong>Gateway</strong></em>. The Gateway is running OpenBSD, the\nclients are Android, iOS, MacOS.</p>\n<p>The <em><strong>iked</strong></em> supports IKEv2 which is suitable for iOS and macOS without\nadditional client, Android could connect via <em><strong>strongSwan</strong></em>. iked supports\nauthentication with <em>shared secret</em>, <em>keypair</em> and <em>certificate</em>. The <em>shared\nsecret</em> is the simplest method but least secure because the whole network is at\nrisk if the <em>shared secret</em> is compromised. <em>Keypair</em> is the next simpler\nmethod, but it requires adding the public key to iked every time we add new\nclient. <em>Certificate</em> is the most complicated one, we need to set up a <em><strong>Public\nKey Infrastructure</strong></em> (PKI) for our system, later, we only need to issue a valid\ncertificate for new client, no change to the iked. I will use PKI for my iked\nsetup.</p>\n<h2>Overview</h2>\n<h3>Prerequisites</h3>\n<ul>\n<li>an OpenBSD installation.</li>\n<li>iked is installed by default.</li>\n<li>a self-signed Root CA.</li>\n<li>a server certificate and keypair.</li>\n<li>a client certificate and keypair.</li>\n</ul>\n<h3>Planning the VPN</h3>\n<p><img src=\"./openbsd-vpn/image/orca_vpn.svg\" alt=\"Orca VPN\" title=\"Orca VPN\" class=\"blog-entry__image\" /></p>\n<p>The above diagram shows related components in my setup.</p>\n<p>The Gateway is running OpenBSD, I will need 2 services:</p>\n<ul>\n<li><em><strong>pf</strong></em>: filter and route traffic between network interfaces.\n<code>net.inet.ip.forwarding=1</code> should be set for pf routing.</li>\n<li><em><strong>iked</strong></em>: manage VPN connections.</li>\n</ul>\n<p>PKI plays important role to make sure the VPN connection is established and\nsecured. Because I use <em><strong>self-signed Root CA</strong></em>, the <em><strong>Root CA</strong></em> should be\ninstalled on both iked and clients. Otherwise, the systems will not trust server\nand client certificates.</p>\n<h2>Step 1 · Generate CA, certificate and keypair in PEM format</h2>\n<p>I use self-signed CA to create all certificates:</p>\n<ul>\n<li>Root CA certificate and intermediate CA.</li>\n<li>Server certificate.</li>\n<li>Client certificate.</li>\n</ul>\n<p>I prepared these CAs and keypair in my Macbook because I don't want to leak my\nRoot CA private key. I use JDK's <em><strong>keytool</strong></em> for generating CA and keypair.</p>\n<h3>Generate self-signed Root Certificate Authority.</h3>\n<p>I will create a PKCS12 keystore named <code>root_ca.pfx</code> to store the self-signed\nRoot CA and its private key. The keystore should be secured at all cost to\nprotect the system trusted in it.</p>\n<pre><code>keytool -keystore root_ca.pfx \\\n    -storetype pkcs12 \\\n    -alias example_root_ca \\\n    -genkeypair \\\n    -keyalg EC \\\n    -keysize 256 \\\n    -sigalg SHA256withECDSA \\\n    -validity 3654 \\\n    -ext bc:c\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li><code>-keystore root_ca.pfx</code>: use the keystore <code>root_ca.pfx</code>, create new keystore\nif it's not existed.</li>\n<li><code>-storetype pkcs12</code>: use PKCS12 format which is supported by many programs,\nespecially Apple Configurator 2.</li>\n<li><code>-alias example_root_ca</code>: the keystore can store many alias, I will store the\nnew Root CA to alias called <code>example_root_ca</code>.</li>\n<li><code>-genkeypair</code>: tell keytool to generate a keypair (public key and private\nkey).</li>\n<li><code>-keyalg EC</code>, <code>keysize 256</code>: the algorithm used to create the keypair. EC mean\nECDSA, a modern algorithm. It's more secure than RSA and the key size is\nshorter (256 compare to RSA's 2048).</li>\n<li><code>-sigalg SHA256withECDSA</code>: the method to self-sign the Root CA. It should\nmatch with <code>-keyalg</code>.</li>\n<li><code>-validity 3654</code>: the Root CA will valid for next 10 years.</li>\n<li><code>-ext bc:c</code>: indicate this is Root CA.</li>\n</ul>\n<p>When running the above command, keytool ask for information about the Root CA,\nenter what suitable for you.</p>\n<ul>\n<li>Keystore password: this password will protect all aliases in the keystore.</li>\n<li>First and last name (<em><strong>Common Name</strong></em> of the certificate)?</li>\n<li>Organizational unit?</li>\n<li>Organization?</li>\n<li>City?</li>\n<li>State?</li>\n<li>Country?</li>\n</ul>\n<h3>Generate and sign intermediate CA.</h3>\n<p>I can use the Root CA to sign server &amp; client certificate, but it will risk all\nsystems if the Root CA is compromised. Because our systems will trust any\ncertificates signed by this Root CA. The good practice is creating an\nintermediate certificate and using this certificate to sign server &amp; client\ncertificates. If the intermediate certificate is compromised, I will add it to\n<em><strong>Certificate Revocation List</strong></em> (CRL) and our systems will not trust it\nanymore.</p>\n<p>I will create <code>intermediate_ca.pfx</code></p>\n<pre><code>keytool -keystore intermediate.pfx \\\n    -storetype pkcs12 \\\n    -alias intermediate_ca \\\n    -genkeypair \\\n    -keyalg EC \\\n    -keysize 256 \\\n    -sigalg SHA256withECDSA\n</code></pre>\n<p>I will create a <em><strong>sign request</strong></em> for intermediate CA and use the Root CA to\nsign the intermediate CA. You can read more about how PKI work to know why we\nshould do these steps.</p>\n<p>Create sign request.</p>\n<pre><code>keytool -keystore intermediate.pfx \\\n    -alias intermediate_ca \\\n    -certreq -file intermediate_ca.certreq\n</code></pre>\n<p>Use Root CA to sign the intermediate certificate.</p>\n<pre><code>keytool -keystore root_ca.pfx \\\n    -alias root_ca\n    -gencert \\\n    -rfc \\\n    -ext BC=0 \\\n    -validity 3650 \\\n    -infile intermediate_ca.certreq \\\n    -outfile intermediate_ca.crt\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li><code>-alias root_ca</code>: we will use <code>root_ca</code> to sign the intermediate certificate.</li>\n<li><code>-gencert</code>: sign the certificate.</li>\n<li><code>-rfc</code>: use PEM format for the signed certificate.</li>\n<li><code>-ext BC=0</code>: indicate this is intermediate CA.</li>\n<li><code>-validity 3650</code>: the CA will be valid for next 10 years.</li>\n<li><code>-infile intermediate_ca.certreq</code>: the sign request of the intermediate\ncertificate.</li>\n<li><code>-outfile intermediate_ca.crt</code>: the intermediate certificate signed by Root\nCA.</li>\n</ul>\n<p>Import the signed certificate to <code>intermediate_ca.pfx</code> for storage. We need to\nimport the Root CA first, because the keytool only allow us importing the valid\ncertificate. Without the Root CA in keystore, keytool will not trust our\nself-signed certificates.</p>\n<pre><code># Export Root CA from root_ca.pfx.\nkeytool -keystore root_ca.pfx -alias root_ca -exportcert -rfc -file root_ca.crt\n# Import Root CA to intermediate_ca.pfx.\nkeytool -keystore intermediate_ca.pfx -alias root_ca -importcert -trustcacerts -file root_ca.crt\n# Import signed certificate to intermediate_ca.pfx.\nkeytool -keystore intermediate_ca.pfx -alias intermediate_ca -importcert -file intermediate_ca.crt\n</code></pre>\n<h3>Generate VPN server certificate.</h3>\n<p>I will create the VPN server certificate and store in <code>vpn_server.pfx</code>, this\ncertificate will have important <code>-ext SAN=DNS:&lt;hostname&gt;</code> option.</p>\n<pre><code>keytool -keystore vpn_server.pfx \\\n    -storetype pkcs12 \\\n    -alias vpn_server \\\n    -genkeypair \\\n    -keyalg EC \\\n    -keysize 256 \\\n    -sigalg SHA256withECDSA\n</code></pre>\n<p>I will repeat the steps that I've done for intermediate certificate:</p>\n<ul>\n<li>Sign VPN server with intermediate CA.\n<ul>\n<li>Remember to replace the <code>-ext BC=0</code> with <code>-ext SAN=DNS:vpn.example.com</code>\nbecause the certificate will be used for VPN server. It's important that the\nCommon Name also use the same value with this option.</li>\n<li><code>-validity 366</code>: the server certificate will have shorter valid time, to\nmake sure I remember how to manage them.</li>\n</ul></li>\n<li>Import Root CA to <code>vpn_server.pfx</code>.</li>\n<li>Import signed server certificate to <code>vpn_server.pfx</code>.</li>\n</ul>\n<h3>Generate client certificate.</h3>\n<p>Generating the client certificate will be similar to server certificate except\nthe option <code>-ext SAN=DNS:vpn.example.com</code> is replaced by\n<code>-ext SAN=email:user@vpn.example.com</code>. The <code>user</code> is used to identify individual\nclient. In the end, I will have a keystore <code>vpn_user.pfx</code>, I will use this\nkeystore, together with <code>root_ca.crt</code> and <code>intermediate_ca.crt</code>, to configure\nthe VPN client.</p>\n<p>I will generate a certificate for each client in my home (phones, Macbooks).</p>\n<h2>Step 2 · Set up PKI for iked</h2>\n<p>I will put all certificates and keypair in the previous steps to iked. It\nrequires some preparation:</p>\n<ul>\n<li>Export Root CA to <code>root_ca.crt</code>.</li>\n<li>Export Intermediate CA to <code>intermediate_ca.crt</code>.</li>\n<li>Export VPN server certificate to <code>vpn_server.crt</code>.</li>\n<li>Export VPN server private key to <code>vpn_server.key</code>. Use this command:\n<code>openssl pkcs12 -in vpn_server.pfx -nocerts -out vpn_server.key -nodes</code></li>\n</ul>\n<p>Build the <code>ca.crt</code> by combining the <code>root_ca.crt</code> and <code>intermediate_ca.crt</code>, it\nwill look like:</p>\n<pre><code>-----BEGIN CERTIFICATE-----\n&lt;intermediate-ca&gt;\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\n&lt;root-ca&gt;\n-----END CERTIFICATE-----\n</code></pre>\n<p>Copy the certificates and private key to their places:</p>\n<ul>\n<li>Rename <code>/etc/iked/local.pub</code> to <code>/etc/iked/local.pub.original</code></li>\n<li>Rename <code>/etc/iked/private/local.key</code> to <code>/etc/iked/private/local.key.original</code></li>\n<li>Copy <code>ca.crt</code> to <code>/etc/iked/ca/ca.crt</code></li>\n<li>Copy <code>vpn_server.crt</code> to <code>/etc/iked/certs/vpn.example.com.crt</code></li>\n<li>Copy <code>vpn_server.key</code> to <code>/etc/iked/private/local.key</code></li>\n</ul>\n<p><strong>Important</strong>: all certificates should have <code>640</code> permission.</p>\n<h2>Step 3 · Configure iked</h2>\n<h3>Enable iked</h3>\n<p>iked is disabled by default, I will enable it.</p>\n<pre><code>rcctl enable iked\n</code></pre>\n<h3>iked configuration</h3>\n<p>Create a <code>/etc/iked.conf</code> with permission <code>640</code>, otherwise iked will complain\nabout incorrect permission.</p>\n<pre><code>ikev2 &quot;Example VPN&quot; passive esp \\\n  from dynamic to any \\\n  from any to dynamic \\\n  peer any \\\n  ikesa enc aes-256 \\\n    prf hmac-sha2-256 \\\n    auth hmac-sha2-256 \\\n    group modp2048 \\\n  childsa enc aes-256 \\\n    auth hmac-sha2-256 \\\n    group modp2048 \\\n  srcid vpn.example.com \\\n  lifetime 180m bytes 16G \\\n  config address 192.168.120.0/24 \\\n  config name-server 8.8.8.8 \\\n  config name-server 8.8.4.4 \\\n  tag &quot;$name-$id&quot;\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li><code>from dynamic to any</code>: traffic from VPN IP to any host will match with this\nconfiguration.</li>\n<li><code>from any to dynamic</code>: traffic from any host response to VPN IP will match\nwith this configuration.</li>\n<li><code>peer any</code>: the peer (client) can connect to Gateway from any IP address.</li>\n<li><code>srcid vpn.example.com</code>: will tell iked to use the certificate / private key\n<code>vpn.example.com</code>.</li>\n<li><code>config address 192.168.120.0/24</code>: the network of VPN, required to use\n<code>dynamic</code> keyword.</li>\n</ul>\n<p>Check configuration.</p>\n<pre><code>iked -n\n</code></pre>\n<p>Start iked.</p>\n<pre><code>rcctl enable iked\n</code></pre>\n<h3>Assign static IP for enc0</h3>\n<p>When iked started, the VPN interface appeared as <code>enc0</code> but no IP is assigned,\nthis setting will work fine unless I want to listen on that interface. In my\ncase, I will assign <code>192.168.120.1</code> to <code>enc0</code>. In fact, this IP already assigned\nto the VPN server, but we need this explicit step to listen on that address. In\nmy case, I will set up an Unbound DNS server only listen on the VPN interface.</p>\n<pre><code>/etc/hostname.enc0\n---\ninet 192.168.120.1 255.255.255.0\n</code></pre>\n<p>Apply the change.</p>\n<pre><code>sh /etc/netstart\n</code></pre>\n<h2>Step 4 · Configure pf</h2>\n<h3>Enable IP forwarding to let the kernel forward packages destined to other hosts.</h3>\n<pre><code>doas sysctl net.inet.ip.forwarding=1\ndoas sh -c 'echo &quot;net.inet.ip.forwarding=1&quot; &gt;&gt; /etc/sysctl.conf'\n</code></pre>\n<h3>pf configuration</h3>\n<p>Allow port <code>500/udp</code> and <code>4500/udp</code>, NAT source address from VPN to public\naddress.</p>\n<pre><code>/etc/pf.conf\n---\nwan = vio0\nvpn = enc0\n...\nmatch out on $wan inet nat-to ($wan:0)\npass in quick on $wan inet proto udp from any to ($wan:0) port {500, 4500} keep state label ipsec\npass in quick on $vpn inet keep state (if-bound)\n</code></pre>\n<p>Reload pf rules</p>\n<pre><code>pfctl -f /etc/pf.conf\n</code></pre>\n<h2>Step 5 · Client configuration</h2>\n<p>Use <em><strong>Apple Configurator 2</strong></em> to configure VPN profile for Apple devices.</p>\n<p>General</p>\n<ul>\n<li>Name: Example</li>\n<li>Identifier: example</li>\n<li>Organization: Example</li>\n</ul>\n<p><img src=\"./openbsd-vpn/image/configurator_general.png\" alt=\"Apple Configurator 2 - General\" title=\"Apple Configurator 2 - General\" class=\"blog-entry__image\" /></p>\n<p>Certificates</p>\n<ul>\n<li>Root CA (root_ca.crt).</li>\n<li>Intermediate CA (intermediate_ca.crt).</li>\n<li>Client certificate and private key (vpn_user.pfx).</li>\n</ul>\n<p><strong>Note</strong>: Apple Configurator 2 only allow PKCS1 and PKCS12 keystore.</p>\n<p><img src=\"./openbsd-vpn/image/configurator_certificates.png\" alt=\"Apple Configurator 2 - Certificates\" title=\"Apple Configurator 2 - Certificates\" class=\"blog-entry__image\" /></p>\n<p>VPN</p>\n<ul>\n<li>Connection Name: Example VPN</li>\n<li>Connection Type: IKEv2</li>\n<li>Server: vpn.example.com</li>\n<li>Remote Identifier: vpn.example.com</li>\n<li>Local Identifier: user@vpn.example.com</li>\n<li>Machine Authentication: Certificate</li>\n<li>Certificate Type: ECDSA</li>\n</ul>\n<p><img src=\"./openbsd-vpn/image/configurator_vpn_1.png\" alt=\"Apple Configurator 2 - VPN 1\" title=\"Apple Configurator 2 - VPN 1\" class=\"blog-entry__image\" /></p>\n<p><img src=\"./openbsd-vpn/image/configurator_vpn_2.png\" alt=\"Apple Configurator 2 - VPN 2\" title=\"Apple Configurator 2 - VPN 2\" class=\"blog-entry__image\" /></p>\n<h2>Reference:</h2>\n<ul>\n<li><a href=\"https://www.going-flying.com/blog/protecting-my-macos-and-ios-devices-with-an-openbsd-vpn.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">https://www.going-flying.com/blog/protecting-my-macos-and-ios-devices-with-an-openbsd-vpn.html</a></li>\n<li><a href=\"https://www.jasworks.org/openbsd-ikev2-home-vpn/\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">https://www.jasworks.org/openbsd-ikev2-home-vpn/</a></li>\n<li><a href=\"https://blog.lambda.cx/posts/openbsd-vpn-gateway/\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">https://blog.lambda.cx/posts/openbsd-vpn-gateway/</a></li>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html</a></li>\n</ul>\n","tags":["iked","openbsd","self-hosted","vpn"]}