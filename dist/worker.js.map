{"version":3,"sources":["worker.js"],"names":["assetCacheName","cacheResources","networkResources","filter","route","indexOf","endsWith","self","addEventListener","event","waitUntil","caches","open","then","assetCache","addAll","hostUrl","URL","target","registration","scope","keys","Promise","all","map","key","console","log","delete","resolve","url","host","pathname","request","respondWith","fetch","response","toBeCachedResponse","clone","cache","put","catch","match","cachedResponse","status","type"],"mappings":"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","file":"worker.js","sourceRoot":"../../src/app","sourcesContent":["const assetCacheName = 'asset';\n// cacheResources will be keep every time we activate service worker, other routes will be cleaned up to reduce cache size.\nconst cacheResources = ['route-place-holder'];\n// networkResources will be fetch for every request.\nconst networkResources = cacheResources.filter(\n  (route) => ['/', '/blog', '/home'].indexOf(route) > -1 || route.endsWith('.html') || route.endsWith('.json'),\n);\n\nself.addEventListener('install', (event) => {\n  // Pre-cache these resources to help page works offline.\n  event.waitUntil(caches.open(assetCacheName).then((assetCache) => assetCache.addAll(cacheResources)));\n});\n\nself.addEventListener('activate', (event) => {\n  // Clean up the caches every time a new version activated to reduce cache size.\n  const hostUrl = new URL(event.target.registration.scope);\n  event.waitUntil(\n    caches\n      .keys()\n      .then((keys) =>\n        Promise.all(\n          keys.map((key) => {\n            console.log('Found cache: ', key);\n            if (key !== assetCacheName) {\n              console.log('Delete out dated cache: ', key);\n              return caches.delete(key);\n            }\n          }),\n        ),\n      )\n      .then(() => caches.open(assetCacheName))\n      .then((assetCache) => Promise.all([Promise.resolve(assetCache), assetCache.keys()]))\n      .then(([assetCache, keys]) =>\n        Promise.all(\n          keys.map((key) => {\n            const url = new URL(key.url);\n            if (hostUrl.host !== url.host || cacheResources.indexOf(url.pathname) === -1) {\n              console.log('Clean up outdated resource: ', key.url);\n              return assetCache.delete(key);\n            }\n            console.log('Resource unchanged, keep the cache: ', key.url);\n          }),\n        ),\n      ),\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  const url = new URL(event.request.url);\n  if (networkResources.indexOf(url.pathname) > -1) {\n    event.respondWith(\n      fetch(event.request)\n        .then((response) => {\n          const toBeCachedResponse = response.clone();\n          caches.open(assetCacheName).then((cache) => cache.put(event.request, toBeCachedResponse));\n          console.log('Fetched network resource: ', url);\n          return response;\n        })\n        .catch(() => {\n          console.log('Network error, return cached network resoure: ', url);\n          return caches.match(event.request);\n        }),\n    );\n  } else {\n    event.respondWith(\n      caches.match(event.request).then((cachedResponse) => {\n        // Cache hit - return response\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return fetch(event.request).then((response) => {\n          // Check if we received a valid response\n          if (!response || response.status !== 200 || response.type !== 'basic') {\n            return response;\n          }\n\n          // IMPORTANT: Clone the response. A response is a stream\n          // and because we want the browser to consume the response\n          // as well as the cache consuming the response, we need\n          // to clone it so we have two streams.\n          const toBeCachedResponse = response.clone();\n\n          caches.open(assetCacheName).then((cache) => {\n            cache.put(event.request, toBeCachedResponse);\n          });\n\n          return response;\n        });\n      }),\n    );\n  }\n});\n"]}